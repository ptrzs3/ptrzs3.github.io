<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Galaxy</title>
    <link>https://ptrzs3.github.io/tags/rust/</link>
    <description>Recent content in Rust on Galaxy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 08 Mar 2024 09:28:53 +0800</lastBuildDate><atom:link href="https://ptrzs3.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>String、&amp;String、str和&amp;str</title>
      <link>https://ptrzs3.github.io/posts/string%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Fri, 08 Mar 2024 09:28:53 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/string%E7%9B%B8%E5%85%B3/</guid>
      <description>String、&amp;amp;String、str和&amp;amp;str简析Link to headingstrLink to headingstr是primitive type，即原始类型，是Rust语言级别上的唯一一种字符串类型。
str类型也称为字符串切片，常以其引用的形式&amp;amp;str出现（也就是字符串字面量，即&amp;amp;&#39;static str）。
Q：既然是static生命周期，为什么在结构体中还需要标注生命周期呢？
圣经：在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。
str类型是动态尺寸类型（Dynamic Size Type）。和u32类型对比，一个u32类型无论数值在u32允许的范围之间如何变化，u32占用的内存都是4字节，因此u32类型是定长类型，原则上是存放在栈区。而对于str，看下面这样的代码：
let str_a: &amp;amp;str = &amp;#34;Hello&amp;#34;; let str_b: &amp;amp;str = &amp;#34;I Love Rust&amp;#34;; 上述代码中，str_a的长度是5个字节，str_b的长度是11个字节，他们同属str类型，而因为赋值不同导致占用内存空间不同，因此说str是动态尺寸类型，无法存放在栈上。因此，使用str类型时，更多地是使用&amp;amp;str，也就是它的引用，也称为字符串切片。
&amp;amp;strLink to heading引用一般是长度已知的，原则上是存放在栈区（目前还没有发现引用时DST的）。
&amp;amp;str 由两个部分组成：一个指向某些字节的指针和一个长度（查看原文）。
String和&amp;amp;StringLink to headingString并不是Rust核心库的，只是标准库中一个公开的结构体。
在某些函数签名中使用&amp;amp;String类型（String的引用类型），建议更改为&amp;amp;str类型。
fn main() { let bar: String = String::from(&amp;#34;Hello&amp;#34;); foo(&amp;amp;bar); // Ok let baz: &amp;amp;str = &amp;#34;Hello&amp;#34;; foo(baz); // Error } fn foo(_: &amp;amp;String) {} // 将foo的签名改为&amp;amp;str，则baz也可以传递 // fn foo(_: &amp;amp;str) {} 通过上述代码，可以知道&amp;amp;String和&amp;amp;str是不等价的，且&amp;amp;str不能转换为&amp;amp;String，但&amp;amp;String却可以自动Deref为&amp;amp;str。</description>
    </item>
    
    <item>
      <title>Rust中的借用、引用与解引用</title>
      <link>https://ptrzs3.github.io/posts/rust%E4%B8%AD%E7%9A%84%E5%80%9F%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8/</link>
      <pubDate>Fri, 08 Mar 2024 09:17:23 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/rust%E4%B8%AD%E7%9A%84%E5%80%9F%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8/</guid>
      <description>Rust中的借用、引用和解引用Link to heading标准库的介绍：https://rustwiki.org/zh-CN/std/keyword.ref.html（译文）| https://doc.rust-lang.org/std/keyword.ref.html （原版，有能力推荐读这个）
Rust book的介绍：https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html
我们将创建一个引用的行为称为 借用（borrowing）
ref indicates that you want a reference to an unpacked value. （我理解为ref产出一个引用）
Case 0Link to heading// rustwiki: 我们将创建一个引用的行为称为 **借用**（*borrowing*） // 个人认为：在参数传递时，称其为引用或者借用都可 // 引用不侵占所有权，不变更数据的所有者 fn main() { let mut number: i32 = 5; flip(&amp;amp;mut number); println!(&amp;#34;number = {}&amp;#34;, number); } fn flip(para: &amp;amp;mut i32) { *para = -*para; } Case 1Link to headinglet ref a = 5; // &amp;amp;i32 let b = &amp;amp;5; // i32 assert_eq!</description>
    </item>
    
    <item>
      <title>Rust里的小东西</title>
      <link>https://ptrzs3.github.io/posts/rust%E9%87%8C%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/</link>
      <pubDate>Wed, 18 Oct 2023 21:28:06 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/rust%E9%87%8C%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/</guid>
      <description>Rust中常用的小东西Link to headingResultLink to heading在不同的模块中有不同的Result定义，但都是std::result::Result的包装。
std::result::ResultLink to headingpub enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } std::io::ResultLink to headingpub type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Error&amp;gt;; 其中Error：
pub struct Error { repr: Repr, } std::fmt::ResultLink to headingpub type Result = Result&amp;lt;(), Error&amp;gt;; 其中Error：
pub struct Error; std::thread::ResultLink to headingpub type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Box&amp;lt;dyn Any + Send + &amp;#39;static&amp;gt;&amp;gt;; ErrorLink to headingstd::error::ErrorLink to headingpub trait Error: Debug + Display { fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn Error + &amp;#39;static)&amp;gt; { .</description>
    </item>
    
    <item>
      <title>Rust命令行解析程序：Clap</title>
      <link>https://ptrzs3.github.io/posts/clap/</link>
      <pubDate>Fri, 13 Oct 2023 20:54:44 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/clap/</guid>
      <description>Rust命令行解析程序：ClapLink to heading基于Clap 4.4.6
参考资料：Clap官方手册
Chapter 1Link to heading配置解析器Link to heading使用Command结构体的new方法构建解析器：
// arg.exe use clap::{arg, Command}; fn main() { // 只要调用clap解析命令行参数，--help和--version会自动添加到命令行参数列表中 // 使用arg!宏定义了两个命令行参数：two, one let matches = Command::new(&amp;#34;MyApp&amp;#34;) .version(&amp;#34;1.0&amp;#34;) .author(&amp;#34;Kevin K. &amp;lt;kbknapp@gmail.com&amp;gt;&amp;#34;) .about(&amp;#34;Does awesome things&amp;#34;) .arg(arg!(--two &amp;lt;VALUE&amp;gt;).required(true)) .arg(arg!(--one &amp;lt;VALUE&amp;gt;).required(true)) .get_matches(); println!( &amp;#34;two: {:?}&amp;#34;, matches.get_one::&amp;lt;String&amp;gt;(&amp;#34;two&amp;#34;).expect(&amp;#34;required&amp;#34;) ); println!( &amp;#34;one: {:?}&amp;#34;, matches.get_one::&amp;lt;String&amp;gt;(&amp;#34;one&amp;#34;).expect(&amp;#34;required&amp;#34;) ); } 用法：
arg.exe --two foo --one bar：两个参数分别对应foo和bar arg.exe -h 或 arg.exe --help：输出帮助信息 arg.exe -v 或 arg.</description>
    </item>
    
  </channel>
</rss>
