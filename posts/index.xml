<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Galaxy</title>
    <link>https://ptrzs3.github.io/posts/</link>
    <description>Recent content in Posts on Galaxy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 30 Oct 2023 15:36:26 +0800</lastBuildDate><atom:link href="https://ptrzs3.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>字符集</title>
      <link>https://ptrzs3.github.io/posts/%E5%AD%97%E7%AC%A6%E9%9B%86/</link>
      <pubDate>Mon, 30 Oct 2023 15:36:26 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/%E5%AD%97%E7%AC%A6%E9%9B%86/</guid>
      <description>字符集Link to heading字符集（Character Set），是字符的集合。在Unicode出现之前，常用的字符集有ASCII，GB2312等。世界上有各种各样的语言，每种语言又有各自的字符，而诸如ASCII、GB2312等字符集具有很强的地区性，即只能表达特定地区常用的字符，如ASCII字符集就无法表示中文字符。
1994年，Unicode横空出世，它可以表达世界上已知的绝大多数字符，在这种字符环境下，不再存在语言的编码冲突，在同屏下，可以显示任意语言的字符，因此，Unicode也被称为万国码、统一码。由于Unicode出现比ASCII要晚，因此为了兼容ASCII文档，Unicode将ASCII吸收为子集，即0~127为原生ASCII码。Unicode只是定义了字符所对应的二进制数，而没有规定这些字符如何存储和传输。
Unicode默认版本是UCS-2，即采用定长两个字节来表示字符，取值范围为U+0000~U+FFFF，这样的范围足以表达全球主要语言的大多数字符。但是Unicode为了表示更多的字符，还提供了UCS-4，取值范围U+00000000～U+7FFFFFFF，可表达一百多万字符。
字符编码规则Link to headingUnicode常用的编码规则有UTF-8、UTF-16、UTF-32。
对比 UTF-8 UTF-16 UTF-32 UCS-2 UCS-4 编码空间 0 ~ 10FFFF 0 ~ 10FFFF 0 ~ 10FFFF 0 ~ FFFF 0 ~ 7FFFFFFF 最少编码字节数 1 2 4 2 4 最多编码字节数 4 4 4 2 4 是否依赖字节序 否 是 是 是 是 UCS是定长编码，这种编码方式最大的缺点就是浪费存储空间。对于字符“A”，如果用UCS-2来存储，则其需要占用两个字节，而用UCS-4来存储，则需要占用四个字节。UTF是可变长度的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。同样存储字符“A”，UTF-8只需要占用一个字节；对于汉字，比如“中”，UTF-8需要占用三个字节。
UTF-8的存储规则Link to heading以下是用来编码 UCS-2 的 UTF-8 子集：
字节 位数 最小十六进制值 最大十六进制值 二进制表示的字节序列 1 7 00000000 0000007F 0xxxxxxx 2 11 00000080 000007FF 110xxxxx 10xxxxxx 3 16 00000800 0000FFFF 1110xxxx 10xxxxxx 10xxxxxx 对于单字节的字符，字节的最高位二进制数设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和最初的前128个ASCII标准码是完全相同的。 对于n字节的符号（n &amp;gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码 对于汉字“中”，Unicode编码为“4E2D”，转换成二进制是“100111000101101”。用UTF-8来表示需要占用三个字节：1110 0100 10 111000 10 101101，将每个字节转换为十进制即：228 184 173</description>
    </item>
    
    <item>
      <title>Rust里的小东西</title>
      <link>https://ptrzs3.github.io/posts/rust%E9%87%8C%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/</link>
      <pubDate>Wed, 18 Oct 2023 21:28:06 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/rust%E9%87%8C%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/</guid>
      <description>Rust中常用的小东西Link to headingResultLink to heading在不同的模块中有不同的Result定义，但都是std::result::Result的包装。
std::result::ResultLink to headingpub enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } std::io::ResultLink to headingpub type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Error&amp;gt;; 其中Error：
pub struct Error { repr: Repr, } std::fmt::ResultLink to headingpub type Result = Result&amp;lt;(), Error&amp;gt;; 其中Error：
pub struct Error; std::thread::ResultLink to headingpub type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Box&amp;lt;dyn Any + Send + &amp;#39;static&amp;gt;&amp;gt;; ErrorLink to headingstd::error::ErrorLink to headingpub trait Error: Debug + Display { fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn Error + &amp;#39;static)&amp;gt; { .</description>
    </item>
    
    <item>
      <title>Hadoop集群搭建</title>
      <link>https://ptrzs3.github.io/posts/hadoop/</link>
      <pubDate>Fri, 13 Oct 2023 20:56:12 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/hadoop/</guid>
      <description>前置内容Link to heading在网络上查看本文Link to heading本文可点击此处访问
MarkdownLink to heading什么是MarkdownLink to heading​	Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。
​	由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、CSDN、简书等，甚至还能被用来撰写电子书。
为什么使用MarkdownLink to heading专注于内容而不是形式 纯文本格式，兼容性强 格式转换方便 Markdown语法示例Link to heading直接插入图片（建议使用图床上传）
插入代码块
fn main() { println!(&amp;#34;Hello, world!&amp;#34;); } #include &amp;lt;stdio.h&amp;gt; int main(void) { printf(&amp;#34;Hello, World!&amp;#34;); return 0; } 插入数学公式 $$ f(x_1,x_2,\ldots,x_n) = \left({1 \over x_1}\right)^2+\left({1 \over x_2}\right)^2+\cdots+\left({1 \over x_n}\right)^2 $$
图床Link to heading​	在Markdown文档中插入图片，其实存储在文档中的是图片的路径，而不是图片本身。所以如果只将Markdown文件本身分享出去而没有打包本地图片的话，文档中的图片就无法显示。因此有一种通用的做法是将图片上传到公网，在Markdown中插入图片时使用公网路径，这样只要有网络连接，Markdown中的图片都可以显示。这个存储图片的地址就是图床。一般来说上传到图床的图片不应该是私密信息，因为图床是公开访问权限的。为了使用方便，有软件比如PicGo实现了将本地图片添加到Markdown文档后，自动将图片上传到图床，并将图片路径替换为网络路径。
​	网络上有公益图床，即免费使用（但可能会对上传和下载流量做出限制）的图床。这种图床一般速率较慢，且有闭站的风险，因此建议使用比如腾讯云、阿里云等有保障的厂商提供的图床服务。</description>
    </item>
    
    <item>
      <title>Rust命令行解析程序：Clap</title>
      <link>https://ptrzs3.github.io/posts/clap/</link>
      <pubDate>Fri, 13 Oct 2023 20:54:44 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/clap/</guid>
      <description>Rust命令行解析程序：ClapLink to heading基于Clap 4.4.6
参考资料：Clap官方手册
Chapter 1Link to heading配置解析器Link to heading使用Command结构体的new方法构建解析器：
// arg.exe use clap::{arg, Command}; fn main() { // 只要调用clap解析命令行参数，--help和--version会自动添加到命令行参数列表中 // 使用arg!宏定义了两个命令行参数：two, one let matches = Command::new(&amp;#34;MyApp&amp;#34;) .version(&amp;#34;1.0&amp;#34;) .author(&amp;#34;Kevin K. &amp;lt;kbknapp@gmail.com&amp;gt;&amp;#34;) .about(&amp;#34;Does awesome things&amp;#34;) .arg(arg!(--two &amp;lt;VALUE&amp;gt;).required(true)) .arg(arg!(--one &amp;lt;VALUE&amp;gt;).required(true)) .get_matches(); println!( &amp;#34;two: {:?}&amp;#34;, matches.get_one::&amp;lt;String&amp;gt;(&amp;#34;two&amp;#34;).expect(&amp;#34;required&amp;#34;) ); println!( &amp;#34;one: {:?}&amp;#34;, matches.get_one::&amp;lt;String&amp;gt;(&amp;#34;one&amp;#34;).expect(&amp;#34;required&amp;#34;) ); } 用法：
arg.exe --two foo --one bar：两个参数分别对应foo和bar arg.exe -h 或 arg.exe --help：输出帮助信息 arg.exe -v 或 arg.</description>
    </item>
    
    <item>
      <title>VSCode配置C&#43;&#43;开发环境（MSVC）</title>
      <link>https://ptrzs3.github.io/posts/vscode/</link>
      <pubDate>Fri, 13 Oct 2023 20:53:22 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/vscode/</guid>
      <description>前置知识Link to heading这些内容如果感兴趣可以看一下，不看也不妨碍配置环境，因为我会一步步教你配置。（但我希望你还是看一下，毕竟我写了好久🤣）
C/C++编译器有哪些Link to heading注意我们说的是编译器，而不是集成开发环境（IDE，Integrated Development Environment）。我们平常用的Codeblocks，Visual Studio Code，Dev C++等软件都是开发环境，而不是编译器。
常用的C/C++编译器（更确切地说是编译器套件）有：GCC、MinGW、MSVC等。不同的编译器附有不同的库文件，如果某段代码只用了标准库，那么这段代码很可能用任意C/C++编译器都可以编译通过；而如果某段代码用了特定编译器独有的库文件，那这段代码很可能只能用特定编译器才能编译通过，甚至对该编译器的版本也有要求。
Windows系统的环境变量Link to heading什么是环境变量Link to heading​	环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息（不好理解）。
​	按照下面的方式查看Windows 10的环境变量
​	可以看到环境变量分为两部分：用户变量和系统变量
用户变量：只对当前用户生效，优先级高于系统变量 系统变量：对所有用户生效 ​	你也可以将环境变量理解为一个指针。我们在环境变量中定义一个名为“JAVA_HOME”的变量，它指向jdk的安装目录。在某段代码中你可能经常使用jdk作为参数，但如果jdk的安装目录变了，怎么办？你在程序中如果直接使用jdk的绝对路径，那你就从代码中找出来一个个地改吧；而如果你在程序中使用JAVA_HOME这个环境变量，当jdk的安装目录发生变化时，你只要改一下JAVA_HOME的内容即可，而你的代码无需任何修改，因为你的代码使用的是JAVA_HOME，而不是jdk的绝对路径。
​	想象这样一个场景：你编写了一个个性化的计算器软件，软件的路径为：D:\softwares\myself\calc.exe
​	当你每次启动时，要么用文件管理器找到这个软件双击运行，要么通过命令行D:\softwares\myself\calc.exe执行。诚然，这两种方式耗费精力都差不多，因为calc.exe并没有位于很深层的目录下。那如果calc.exe位于第10层，甚至第100层目录呢，是不是每次打开这个软件很费劲？因为你要么需要打开100层文件夹，要么在命令行输入calc.exe的路径，都是很费劲的方法（当然你可以创建快捷方式，但我们先不考虑这种方法）。
​	这时候，你就可以把calc.exe所在的目录添加到用户变量的Path变量下（你也可以添加到系统变量的Path下，这样就对所有用户生效了），这样每次执行calc.exe都不需要在命令行中输入那么一长串路径，而只需要输入calc.exe或者calc即可。
Path环境变量Link to heading​	Path是个很重要的环境变量，他里面存储的一般是一系列可执行文件的目录。
​	下图所示是系统变量中的Path存储的内容，每一行代表一个目录，许多目录都是以“bin”（binary的缩写）结尾，代表该目录下存储了一些二进制的可执行文件。执行这些目录下的可执行文件不需要加一长串的路径，只需要在命令行输入可执行文件的名称即可。
其他环境变量Link to heading​	比如我们前面提到的“JAVA_HOME”环境变量，这其实就是一个普通的环境变量。你可以随便定义自己的环境变量，比如isjks：wwoqsi。你可以在命令行中执行echo %isjks%，会输出wwoqsi。当然这个并没有任何意义，我只是告诉你你可以随便定义自己的环境变量，无论这个变量有没有什么用。
​	在上面一张图中，我们发现有些被百分号“%”包裹起来的东西，这些被包裹起来的，其实是已经定义的环境变量。比如SystemRoot的内容就是“C:\WINDOWS”。有些环境变量并没有在环境变量列表中被列出来，因此无法直接看到它的值。如果你对任何环境变量感兴趣，可以在命令行中执行echo %&amp;lt;ENV_VAR&amp;gt;%来查看它代表的内容。
安装Visual Studio CodeLink to heading​	这个没有难度，自己安装即可。vscode安装完成后会把自己加到环境变量，提示需要重启一下电脑。
安装VIsual Studio及相关附件Link to heading​	在这里下载installer，选择社区版即可。</description>
    </item>
    
    <item>
      <title>Git基础</title>
      <link>https://ptrzs3.github.io/posts/git/</link>
      <pubDate>Fri, 13 Oct 2023 20:52:20 +0800</pubDate>
      
      <guid>https://ptrzs3.github.io/posts/git/</guid>
      <description>GitLink to headingGit的配置信息Link to heading使用git config命令对Git做一些配置。
Git的配置文件等级Link to headingGit的配置文件有三个，分别对应不同的影响等级：
Linux下
/etc/gitconfig：包含系统上每个用户及他们仓库的通用配置，使用git config --system更改
~/.gitconfig 或 ~/.config/git/config：针对当前用户的配置文件，使用git config --global修改
.git/config：针对当前仓库的配置文件，使用git config修改
Windows下
$Git/etc/gitconfig $HOME/.gitconfig .git/config 读取配置时优先读取当前仓库的配置，如果没有就往上找
修改Git配置Link to heading修改全局配置：git config --global user.name &amp;quot;zhangsan&amp;quot; 查看当前的Git配置Link to headinggit config --list
Git基础Link to heading初始化Git仓库Link to heading将当前目录初始化为Git仓库：git init
如果当前目录中已经有一些文件存在，使用git add &amp;lt;filename&amp;gt;来跟踪某个文件即将其提交到暂存区，或者git add .跟踪当前目录所有文件并提交到暂存区
克隆已有的仓库Link to heading克隆github上某个仓库：git clone &amp;lt;url&amp;gt;</description>
    </item>
    
  </channel>
</rss>
